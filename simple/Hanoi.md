>题目：有三根杆子A，B，C。A杆上有 N 个 (N>1) 穿孔圆盘，盘的尺寸由下到上依次变小。要求按下列规则将所有圆盘移至C杆：
>1. 每次只能移动一个圆盘
>2. 大盘不能叠在小盘上面
>
>提示：可将圆盘临时置于 B 杆，也可将从 A 杆移出的圆盘重新移回 A 杆，但都必须遵循上述两条规则
>
>问：如何移？最少要移动多少次？


这是一个非常经典的递归问题，对于递归问题的解法，通常都是将复杂的问题，拆解成多个类似的子问题。对于汉诺塔问题，相对简单的情况，可以假设N=2，此时移动的办法如下：

1. 将1号圆盘由A移到B
2. 将2号圆盘由A移到C
3. 然后将1号圆盘由B移到C

![](https://imgkr.cn-bj.ufileos.com/edb99a20-92a9-44e3-8e71-9ce57b8b1b16.png)


**如果对于N比较大的情况如何处理？**

递归的思想就是将大的问题化解成小的问题进行处理，那其实就可以把N个圆盘看成两个部分，假设圆盘是从上到下依次编号为1、2、3、...、n，第一部分为最下边那个编号为n的圆盘，第二部分为上边的n-1个圆盘。这样就把有N个圆盘的汉诺塔问题转换成了只有两个圆盘的汉诺塔问题了。然后就可以按照下边步骤进行移动圆盘：

* 将上边n-1个圆盘由A移动到B
* 然后将编号为n的圆盘(最下边那个)由A移动到C
* 最后将上边n-1个圆盘由C移动到B

![](https://imgkr.cn-bj.ufileos.com/926f6d91-f77d-4d12-957f-fdec92598cc7.png)


通过这种方式，就可以将移动N个圆盘的汉诺塔问题转化成了移动N-1个圆盘的汉诺塔问题。而移动N-1个圆盘的汉诺塔问题，又可以进一步转化为移动N-2个圆盘的汉诺塔问题，以此类推。用递归就很好解决了，递归的终止条件就是一个圆盘的汉诺塔问题，就是直接将圆盘由A移动到C。知道了终止条件，那整个递归就相当于可以求解了

下边就是通过代码来实现(将n个圆盘由A通过B移动到C)

实现过程：

首先就是要考虑终止的情况，也就是n=1的时候(n为圆盘的个数)，这个时候就可以直接将圆盘由A移动到C
如果n>=2时就按照如下步骤进行移动

1. 第一步将上边n-1个圆盘作为一个整体由A移动到B上
2. 第二步就是将最下边的第n个圆盘直接由A移动到C
3. 第三步就是将那n-1个圆盘由B移动到C上

```
class Hanoi
{
    /**
     * n个圆盘，由a移动到c
     *
     * @param $n integer 圆盘的个数
     * @param $a string 柱子A
     * @param $b string 柱子B
     * @param $c string 柱子C
     */
    public function hanoiFunc($n, $a, $b, $c)
    {
        if ($n ==1) {
            $this->Move($n, $a, $c);
        } else {
            $this->hanoiFunc($n-1, $a, $c, $b);//递归调用，由a移动到b，c为临时
            $this->Move($n, $a, $c);
            $this->hanoiFunc($n-1, $b, $a, $c);//递归调用，由b移动到c，b为临时
        }
    }

    public function Move($n, $a, $c)
    {
        $string = "移动 ".$n."号圆盘: 由 ".$a." 移动到 ".$c.PHP_EOL;
        echo $string;
    }
}
$hanoi = new Hanoi();
$hanoi->hanoiFunc(3, 'A', 'B', 'C');
```

运行结果：
![](https://imgkr.cn-bj.ufileos.com/e6a15424-76bc-40e9-89f0-83a815450126.png)


